# JPA STUDY

### ✨지난날 기능 위주의 공부법을 반성하고, 개념부터 다시 공부하기 위한 프로젝트

## JPA 란?
SQL 중심 개발의 문제점은 개발자가 CRUD라고 불리는 INSERT, UPDATE, SELECT, DELETE
문을 작성해서 객체를 관계형 데이터베이스에 널어주고 가져오는 작업을 하는 것이다.
개발자가 SQL을 매핑하는 역할을 반복해야 한다는 의미

또한 객체와 관계형 데이터베이스의 페러다임의 불일치가 가장 큰 문제이다.
자바는 객체 지향 페러다임으로 만들어졌고, 관계형 데이터베이스는 데이터를 정규화해서
잘 보관하는 것을 목표로 한다.

객체를 데이터베이스에 넣기 위해서는 SQL문을 통해 변환해서 저장해야 하고,
데이터베이스에서 객체를 데이터베이스에 넣기 위해서는 SQL문을 작성해야 한다.
결국 객체를 단순히 데이터 전달 목적으로 사용할 뿐 객체지향적으로 프로그래밍 할 수 없다.
이는 객체지향과 관계형 데이터베이스 간의 페러다임이 불일치하기 때문에 이에 대한 해결법으로 ORM 기술이 나왔다.

객체는 객체지향적으로, 데이터베이스는 데이터베이스 대로 설계를 해야한다.
그리고 ORM은 중간에서 2개를 매핑하는 역할을 한다. 이를 통해 개발자는
소스를 조금더 객체지향적으로 설계를 하고 비지니스 로직에 집중할 수 있다.

![ORM을 이용한 자바 객체와 관계형 데이터베이스 매핑](https://user-images.githubusercontent.com/75296934/218662852-ff6c371f-4e53-4759-9019-bff33fe93897.PNG)

## JPA 사용 시 장점

### 1. 특정 데이터베이스에 종속되지 않음
Oracle을 사용하다가 MariaDB로 변경하게 된다면 쿼리문 전체를 수정해야 한다.
하지만 JPA는 추상화한 데이터 접근 계층을 제공하기 때문에 설정 파일에 어떤 데이터베이스를
사용하는지 알려주면 언제든 데이터베이스를 변경할 수 있다.

### 2. 객체지향적 프로그래밍
JPA를 사용하면 데이터베이스 설계 중심의 페러다임에서 객체지향적으로 설계가 가능하기 때문에
좀 더 직관적이고 비지니스 로직에 집중할 수 있도록 도와준다.

### 3. 생산성 향상
데이터베이스 테이블에 새로운 컬럼이 추가되었을 경우, 해당 테이블의 컬럼을 사용하는 DTO 클래스의
필드도 모두 변경해야 합니다. JPA에서는 테이블고 매핑된 클래스에 필드만 추가된다면 쉽게 관리가 가능
또한 SQL문을 직접 작성하지 않고 객체를 사용하여 동작하기 때문에 유지보수 와 재사용성도 증가

## JPA 사용 시 단점

### 1. 복잡한 쿼리 처리
통계 처리 같은 복잡한 쿼리를 사용할 경우 SQL문을 사용하는 게 나을 수도 있다.
JPA에서는 Native SQL을 통해 기존의 SQL문을 사용할 수 있지만 그러면 특정 데이터베이스에 종속된다는
단점이 생긴다. 해서 이를 보안하기 위해 SQL과 유사한 기술인 JPQL을 지원한다.

### 2. 성능 저하 위험
객체 간의 매핑 설계를 잘못했을 때 성능 저하가 발생할 수 있으며, 자동으로 생성되는
쿼리가 많기 때문에 개발자가 의도하지 않는 쿼리로 성능이 저하되기도 한다.

### 3. 학습 시간
JPA를 제대로 사용하려면 알아야 할 것이 많아서 학습 시간이 오래 걸린다.
관계형 데이터베이스를 충분히 알아야 JPA를 잘 사용할 수 있기 때문에 관계형 데이터베이스를
학습 후 사용하는것을 권장한다.

## JPA 동작 방식

![JPA 동작 방식](https://user-images.githubusercontent.com/75296934/218662945-58ad8905-222b-41d0-9612-b2ae0c57f6e9.PNG)

### 엔티티(Entity)
Entity란 데이터베이스의 테이블에 대응하는 클래스라고 생각하면 된다.
@Entity가 붙은 클래스는 JPA에서 관리한다.

데이터베이스에 테이블을 만들고 해당 테이블에 대응되는 클래스를 만들어 @Entity 어노테이션을 붙이면
이 클래스가 엔티티가 된다. 클래스 자체나 생성한 인스턴스도 엔티티라고 부른다.

### 엔티티 메니저 팩토리(Entity Manager Factory)
엔티티 메니저 인스턴스를 관리하는 주체이다. 어플리케이션 실행 시 한 개만 만들어지며 사용자로부터
요청이 오면 엔티티 메니저 팩토리로부터 엔티티 메니저를 생성한다.

### 엔티티 메니저(Entity Manager)
영속성 컨텍스트에 접근하여 엔티티에 대한 데이터베이스 작업을 제공한다.
내부적으로 데이터베이스 커넥션을 사용해서 데이터베이스에 접근한다.

1. find() 메소드 : 영속성 컨텍스트에서 엔티티를 검색하고 영속성 컨텍스트에 없을 경우 데이터베이스에서 데이터를 찾아 영속성 컨텍스트에 저장
2. persist() 메소드 : 엔티티 영속성 컨텍스트에 저장한다.
3. remove() 메소드 : 엔티티 클래스를 영속성 컨텍스트에서 삭제한다.
4. flush() 메소드 : 영속성 컨텍스트에 저장된 내용을 데이터베이스에 반영한다.

## 영속성 컨텍스트
JPA를 이해하기 위해서는 영속성 컨텍스트(Persistence Context)를 이해하는 것이 가장 중요하다.
엔티티를 영구 저장하는 환경으로 엔티티 메니저를 통해 영속성 컨텍스트를 접근한다.

![엔티티 생명주기](https://user-images.githubusercontent.com/75296934/218663059-4f2e786d-c4b7-4a9a-9a03-60c310cdd185.PNG)


![엔티티 생명주기의 세부 내용](https://user-images.githubusercontent.com/75296934/218663675-ff0588c2-66b4-41b4-84f1-2df192d65a5b.PNG)

## 영속성 컨텍스트 사용 시 이점
애플리케이션과 데이터베이스 사이에 영속성 컨텍스트라는 중간 계층을 만들어서
버퍼링, 캐싱 등을 할 수 있는 장점이 있다.

![영속성 컨텍스트 1차 캐시 구조](https://user-images.githubusercontent.com/75296934/218664649-e6335b2c-abb2-4536-9f35-865c88af0bf9.PNG)

### 1차 캐시
영속성 컨텍스트에는 1차 캐시가 존재하며 Map<Key, Value>로 저장된다.
EntityManager.find() 메소드 호출 시 영속성 컨텍스트의 1차 캐시를 조회, 엔티티가 존재할 경우 해당 엔티티 반환,
엔티티가 없으면 데이터베이스에서 조회 후 1차 캐시에 저장 및 반환.

### 동일성 보장
1차 캐시에 저장된 엔티티를 조회하기 때문에 하나의 트랜잭션에서 같은 키값으로 영속성 컨텍스트에 저장된 엔티티 조회 시 같은
엔티티 조화 보장이 가능하다.

![영속성 컨텍스트 쓰기 지연 SQL 저장소](https://user-images.githubusercontent.com/75296934/218667647-7285e500-ad3f-4c5f-a33c-a8abb1449eee.PNG)

### 트랜잭션을 지원하는 쓰기 지연
영속성 컨텍스트에는 쓰기 지연 SQL 저장소가 존재한다. EntityManager.persist()를 호출하면 1차 캐시에 저장되는 것과 동시에
쓰기 지연 SQL 저장소에 SQL문이 저장된다. 이렇게 SQL을 쌓아두고 트랜잭션을 커밋하는 시점에
저장된 SQL문들이 flush되면서 데이터베이스에 반영 되기 때문에 성능에서 이점을 볼 수 있다.

### 변경 감지
JPA는 1차 캐시에 데이터베이스에서 처음 불러온 엔티티의 스냅샷 값을 가지고 있다. 그리고 1차 캐시에 저장된 엔티티와 스냅샷을 비교 후
변경 내용이 있디면 UPDATE SQL문을 쓰기 지연 SQL 저장소에 담아두고 데이터베이스에 커밋 시점에 변경 내용을 자동으로 반영하기 때문에
따로 update문을 호출할 필요가 없다.

Spring Data JPA는 JPA 구현체를 스프링에 맞춰 더욱 쉽게 사용할 수 있도록 도와주는 모듈이다.

## Auditing
사전적 의미는 '감시하다'이다.<br>
Spring Data JPA에서는 Auditing 기능을 제공하여 엔티티가 저장 또는 수정될 때
자동으로 등록일, 수정일, 등록자, 수정자를 입력해 준다.
